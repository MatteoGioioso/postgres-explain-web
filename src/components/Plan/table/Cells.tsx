import React from "react";
import {Box, Collapse, Popover, TableCell, Typography} from "@mui/material";
import {useTheme} from "@mui/material/styles";
import {betterDiskSize, betterNumbers, betterTiming, getPercentageColor} from "../utils";
import {PlanRow, Stats} from "../types";

export const GenericDetailsPopover = (props: { name: string, content: any, children: any, keepCloseCondition?: boolean, style?: any }) => {
    const [anchorEl, setAnchorEl] = React.useState<HTMLElement | null>(null);

    const handlePopoverOpen = (event: React.MouseEvent<HTMLElement>) => {
        if (props.keepCloseCondition) return
        setAnchorEl(event.currentTarget);
    };

    const handlePopoverClose = () => {
        setAnchorEl(null);
    };

    const open = Boolean(anchorEl);

    return (
        <>
            <span
                aria-owns={open ? 'mouse-over-popover' : undefined}
                aria-haspopup="true"
                onMouseEnter={handlePopoverOpen}
            >
                {props.children}
            </span>
            <Popover
                id="mouse-over-popover"
                sx={{
                    width: '1200px',
                    ...props.style
                }}
                open={open}
                anchorEl={anchorEl}
                anchorOrigin={{
                    vertical: 'bottom',
                    horizontal: 'left',
                }}
                transformOrigin={{
                    vertical: 'top',
                    horizontal: 'left',
                }}
                onClose={handlePopoverClose}
                disableRestoreFocus
                slotProps={{paper: {onMouseLeave: handlePopoverClose}}}
            >
                <Box sx={{p: 1.2}}>
                    {props.content}
                </Box>
            </Popover>
        </>
    )
}

export const getRowEstimateDirectionSymbol = (direction: string): string => {
    switch (direction) {
        case 'over':
            return '↑'
        case 'under':
            return '↓'
        default:
            return ''
    }
}

export const TimingCell = ({prop, totalProp, name}: { prop: number, totalProp: number, name?: string }) => {
    const theme = useTheme();
    return (
        <TableCell
            component="th"
            style={{
                backgroundColor: getPercentageColor(prop, totalProp, theme)
            }}>
            {betterTiming(prop)}
        </TableCell>
    )
}

export const headCells = (areBuffersPresent?: boolean) => [
    {
        id: 'exclusive',
        label: 'Time',
        align: 'left',
        disablePadding: false,
        description: "Total node time per worker"
    },
    {
        id: 'inclusive',
        label: 'Cumulative Time',
        align: 'left',
        disablePadding: false,
    },
    {
        id: 'rows',
        label: 'Rows',
        align: 'left',
        disablePadding: false,
        description: <div>Total average rows returned per worker.{` `} <br/>
            <b>NOTE</b>: When the parallel portion of the plan generates only a small number of tuples,
            the leader will often behave very much like an additional worker,
            speeding up query execution. Conversely, when the parallel portion of the plan generates a large number of tuples,
            the leader may be almost entirely occupied with reading the tuples generated by the workers and
            performing any further processing steps that are required by plan nodes above the level of the Gather node <br/>
            <a href="https://www.postgresql.org/docs/current/how-parallel-query-works.html" target="_blank">How parallel query works</a>
        </div>
    },
    {
        id: 'rows_x',
        label: 'Rows E',
        align: 'left',
        disablePadding: false,
        description: "Rows estimation factor"
    },
    {
        id: 'loops',
        label: 'Loops',
        align: 'left',
        disablePadding: false,
        description: "Loops / Workers (it also counts the leader)"
    },
    {
        id: 'reads',
        label: 'Reads',
        align: 'left',
        disablePadding: false,
    },
    {
        id: 'written',
        label: 'Written',
        align: 'left',
        disablePadding: false,
    },
    {
        id: 'node',
        label: 'Node',
        align: 'left',
        disablePadding: false,
    },
    {
        id: 'actions',
        label: '',
        align: 'left',
        disablePadding: false,
    },
]

export interface CellProps {
    row: PlanRow
    expanded: boolean
    stats: Stats
    theme?: any
}

export const RowCell = ({row, expanded}: CellProps) => {
    return (
        <TableCell align="left" style={{wordWrap: 'break-word', whiteSpace: 'normal', maxWidth: '150px'}}>
            <GenericDetailsPopover name={"Rows"} content={row.rows.total}>
                {betterNumbers(row.rows.total)}
            </GenericDetailsPopover>
            <Collapse in={expanded} timeout="auto" unmountOnExit>
                <Typography><b>Total</b>: {betterNumbers(row.rows.total * (row.workers.launched + 1))}</Typography>
                {
                    row.scopes.filters && (
                        <>
                            <GenericDetailsPopover name={"rows removed"} content={row.rows.removed}>
                                <b>Removed: </b> - {' '}{betterNumbers(row.rows.removed)}
                            </GenericDetailsPopover>
                            <GenericDetailsPopover name={"filters"} content={<code>{row.scopes.filters}</code>}>
                                <Typography noWrap><b>Filter</b>: <code>{row.scopes.filters}</code></Typography>
                            </GenericDetailsPopover>
                        </>
                    )}
            </Collapse>
        </TableCell>

    )
}

export const BufferReadsCell = ({expanded, row, stats, theme}: CellProps) => {
    return (
        <TableCell style={{backgroundColor: getPercentageColor(row.buffers.effective_blocks_read, stats.max_blocks_read, theme)}}>
            {betterDiskSize(row.buffers.effective_blocks_read)}
            <Collapse in={expanded} timeout="auto" unmountOnExit>
                <Typography
                    variant='subtitle2'>Shared: {betterNumbers(row.buffers.exclusive_reads)}
                </Typography>
                <Typography
                    variant='subtitle2'>Temp: {betterNumbers(row.buffers.exclusive_temp_reads)}
                </Typography>
                <Typography
                    variant='subtitle2'>Temp: {betterNumbers(row.buffers.exclusive_local_reads)}
                </Typography>
            </Collapse>
        </TableCell>
    )
}

export const BufferWrittenCell = ({expanded, theme, row, stats}: CellProps) => {
    return (
        <TableCell style={{backgroundColor: getPercentageColor(row.buffers.effective_blocks_written, stats.max_blocks_written, theme)}}>
            {betterDiskSize(row.buffers.effective_blocks_written)}
            <Collapse in={expanded} timeout="auto" unmountOnExit>
                <Typography
                    variant='subtitle2'>Shared: {betterNumbers(row.buffers.exclusive_written)}
                </Typography>
                <Typography
                    variant='subtitle2'>Temp: {betterNumbers(row.buffers.exclusive_temp_written)}
                </Typography>
                <Typography
                    variant='subtitle2'>Local: {betterNumbers(row.buffers.exclusive_local_written)}
                </Typography>
            </Collapse>
        </TableCell>
    )
}